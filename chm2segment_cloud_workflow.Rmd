---
title: "CHM2Segment workflow"
author: "Andrii Zaiats"
date: "Last updated: 2022-09-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, echo = TRUE, eval = FALSE)
```

#### DenseCloud to segmented crowns workflow using *lidR* package.

The script goes step by step from the dense cloud to the final product that is a geospatial layer of segmented crowns and a raster mask. The following code is a test version of the workflow and may undergo changes/improvements.\

**Raster or Cloud-based tree detection:** The dense cloud is normalized using DTM and has an advantage of using parallelized algorithms for cloud catalog processing in *lidR* package and potentially using structural features that may be lost in converting the dense cloud to a raster. Note, only **Step 2**, the detection of individual trees/shrubs, is different compared to the CHM workflow. Once the shurbs are detected, the region-growing algorithm that generates segments in **Step 3** is efficient and can use the CHM raster without the necessity to parallelize (which is likely faster than using the dense cloud for segmentation).

##### *Steps in the workflow*:

1.  Load Canopy Height Model\
2.  Detect tree tops\
3.  Outline segment boundaries\
4.  Export output.

##### *Required software*

-   R packages: *lidR, future, sf, terra, stars, tidyverse, raster*.

Setting up the environment: first we load the R packages, then provide a system path to the input file and where the output should be stored. We will need a path to the project folder that contains a canopy height model file with *"\*\_chm\_\*"* pattern in the name (could be the same path used in *dem2dtm_workflow.Rmd*). Lastly, we can specify site name, date of data collection, and CRS for consistent naming convention.

```{r, results='hide', message=FALSE}
# load packages
pkgs <- c("lidR", "sf", "stars", "terra", "tidyverse")
sapply(pkgs, require, character.only = TRUE, quietly = TRUE)

# === helper stuff: colours
cols <- gray.colors(255)
colsid <- hcl.colors(50)

# specify paths
path_prj <- "D:/Andrii/20220520_CorralsTrail/products_ownCloud/"
path_out <- paste0(path_prj, "segment_output/")

if(dir.exists(path_out) == FALSE)
  dir.create(path_out)

# data attributes
site <- "CorralsTrail" 
date <- "20220520" # in YYYYMMDD format
prj_crs <- "wgs84utm11n" # eg wgs84utm11n
```

#### Test code for cloud-based tree detection.

```{r, message=FALSE, warning=FALSE}
dir.create(paste0(path_prj, "/chm_cloud/"), showWarnings = FALSE)

ctg <- readLAScatalog(paste0(path_prj, "/tiles/"))

f <- list.files(path_prj, pattern = "_dtm_", full.names = TRUE)
dtm <- rast(f) |>
  crop(extent(ctg) + 5) 
set.values(dtm)

opt_output_files(ctg) <- paste0(path_prj, "/chm_cloud/", "tile_{ID}_norm")

# === normalize height
library(future)
plan(multisession)

ctg_norm <- normalize_height(ctg, algorithm = raster::raster(dtm))

plan(sequential)

```

The following code chunk defines an allometric equation to be used in tree detection. Most likely, the parameters can be set as constants within site, but will likely need to change from one site to the next.

```{r, warning=FALSE, message=FALSE}
# Height-width allometric function, aka moving window radius
ws_fn <- function(x) {
  a <- 2.25; 
  b <- 0.75; 
  h0 <- 0.25
  
  r <- a*tanh(x*b) + .15*x
  r[r < h0] <- h0
  return(r)
}

ctg_norm <- readLAScatalog(paste0(path_prj, "chm_cloud"))
plan(multisession)

ttops <- locate_trees(ctg_norm, lmf(ws = ws_fn, hmin = .1), uniqueness = "bitmerge")
```

```{r, message=FALSE, warning=FALSE}
if(is.character(ttops)) {
  lf <- list.files(paste0(path_prj, "/chm_cloud/"), pattern = ".shp$", full.names = TRUE)

  slist <- lapply(lf, st_read)

  tt <- do.call(rbind, slist) |>
    group_by(treeID) |>
    slice_max(Z) |>
    ungroup() |>
    mutate(treeID = 1:n())
} else {
  tt <- ttops |>
    group_by(treeID)  |>
    slice_max(Z) |>
    ungroup() |>
    mutate(treeID = 1:n())
}


st_write(tt, paste0(path_prj, "segment_output/", site, "_ttops.geojson"), delete_layer = TRUE)

tt |>
  mutate(X = st_coordinates(geometry)[,1], 
         Y = st_coordinates(geometry)[,2]) |>
  as.data.frame() |>
  dplyr::select(-geometry) -> out

write.csv(out, paste0(path_prj, "segment_output/", site, "_ttops.csv"), row.names = FALSE)

```

```{r}
ttops <- st_read(paste0(path_prj, "segment_output/", site, "_ttops.geojson"))

f <- list.files(path_prj, pattern = "_chm_", full.names = TRUE)
chm <- rast(f) |>
  crop(extent(ttops)*1.5)


set.values(chm)
# =============================
cro <- dalponte2016(chm, ttops, th_tree = .15, th_seed = .2, th_cr = .1, max_cr = 150)()

cro |> 
  st_as_stars() |> 
  st_as_sf(as_points = FALSE, merge = TRUE) |> 
  rename(treeID = dsm) |>
  group_by(treeID) |> 
  summarize() -> cro

```

```{r}
plot(chm)
plot(cro$geometry, add = TRUE)
plot(tt$geometry, add = TRUE, pch = 19, cex = .5, col = "black")
```

```{r}
# export 
roi <- chm |> 
  st_bbox() |> 
  st_as_sfc() |> 
  st_buffer(-1)

# tree tops
tout <- ttops |> 
  st_crop(st_bbox(roi)) 

# polygons
cout <- cro |> 
  filter(st_intersects(geometry, st_buffer(tout, .1), sparse = FALSE)[,1] ) 

# save output to disk as a geojson file
tout |> 
  filter(treeID %in% cout$treeID) |>
    st_write(paste0(path_out, site, "_ttops.geojson"), delete_layer = TRUE)

cout |> 
    st_write(paste0(path_out, site, "_crown.geojson"), delete_layer = TRUE)

writeRaster(cro, filename = paste0(path_out, site, "_crowns_raster.tif"), overwrite = TRUE)
```
