---
title: "CHM2Segment workflow"
author: "Andrii Zaiats"
date: "Last updated: 2022-09-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, echo = TRUE, eval = FALSE)
```

#### Canopy Height Model (CHM) to segmented crowns workflow using *lidR* package.

The script goes step by step from the canopy height model to a final product that is a geospatial layer of segmented crowns and a raster mask where a pixel can belong either to a plant or ground. The following code is a test version of the workflow and may undergo changes/improvements.\

**Raster or Cloud-based tree detection:** the script currently includes two parts. Part 1, which goes first, includes all steps to run the segmentation algorithm using a Canopy Height Model raster. The advantage of this approach is that it does not need any point clouds, which is somewhat simpler. Part 2, which is in the end and is currently under development, uses Cloud-based tree detection. The cloud is normalized using DTM and has an advantage of using parallelized algorithms for cloud catalog processing in _lidR_ package. Note, only **Step 2** is different, the region-growing algorithm in **Step 3** and onward is efficient and can be ran on a full raster without the necessity to parallelize. 

##### *Steps in the workflow*:

1.  Load Canopy Height Model\
2.  Detect tree tops\
3.  Outline segment boundaries\
4.  Export output.

##### *Required software*

-   R packages: *lidR, future, sf, terra, stars, tidyverse, raster*.

Setting up the environment: first we load the R packages, then provide system paths to the input file and where the output should be stored. The paths are: (1) path to the project folder that contains a canopy height model file with *"\*\_chm\_\*"* pattern in the name (could be the same path used in *dem2dtm_workflow.Rmd*), and (2) a path to the *segment_output* folder. Lastly, we can specify site name, date of data collection, and CRS for consistent naming convention.

```{r, results='hide', message=FALSE}
# load packages
pkgs <- c("lidR", "raster", "sf", "stars", "terra", "tidyverse", "viridisLite", "ggplot2")
sapply(pkgs, require, character.only = TRUE, quietly = TRUE)

# === helper stuff: colours
cols <- gray.colors(255)
colsid <- sample(viridis(50, alpha = 1, direction = 1, begin = 0))

# specify paths
path_prj <- "~/Downloads/tmp/"
path_out <- paste0(path_prj, "segment_output/")

if(dir.exists(path_out) == FALSE)
  dir.create(path_out)

# data attributes
site <- "CorralsTrail"
date <- "20220520" # in YYYYMMDD format
prj_crs <- "wgs84utm11n"
```
#### 0. Parameter tuning.
This step is optional but is highly recommended before processing the full dataset. The algorithms and order of application are the same, but it operates on a small subset of the data (_e.g._, 20 x 20m) and can be useful to fine-tune input parameters. To run the script on a test dataset, in **Step 1** set `Test = 1`, otherwise set `Test = 0` to run the algorithm on a full dataset. The former will look for a smaller CHM raster generated from cell below.

##### Crop the Canopy Height Model to a smaller footprint.\
The cropping factor is the degree to which the we want to subset the full dataset. Higher number means that the resulting raster will be smaller. 
```{r}
crop_fct <- 2

f <- list.files(path_prj, pattern = "_chm_.*.tif$", full.names = TRUE)
chm <- rast(f)
chm <- crop(chm, ext(chm)/crop_fct)

plot(chm)

writeRaster(chm, filename = paste0(path_prj, "chm_test.tif"))
```
The result of this code chunk should be a small raster named _chm_test.tif_ stored in the project directory. 

#### 1. Load Canopy Height Model.
```{r}
Test <- 1 # this is where we define whether to use the test dataset.
# =================================================================
if(Test == 1) { ptrn = "chm_test.tif$"} else {ptrn = "_chm_.*.tif$" }

f <- list.files(path_prj, pattern = ptrn, full.names = TRUE)
chm <- rast(f)

plot(chm)
```

#### 2. Detect tree tops.
The result from the tree detection algorithm is a spatial point layer. The performance of the algorithm depends on three input parameters: $a, b, h_0$.\

2.1 Increasing $a$ will result in less clumping of individuals and it will affect proportionally small and large plants.  Really small values will result in about equal clumping of smaller plants close to the ground surface and on top of larger shrubs (_i.e._, individual branches sticking up will be treated as individual shrubs).\
2.2 Higher values for $b$ will result in fewer plants detected close to the edge of larger individuals. In other words, while larger individuals should still be detected, smaller plants may be missed when located closer to larger ones.\
2.3 The value for $h_0$ controls the minimum search radius and accounts for the possibility that CHM may contain negative values. Smaller values for $h_0$ will likely result in more plants detected close to the ground surface.\

```{r, message=FALSE, results='hide'}
# Allometric function, aka moving window radius
ws_fn <- function(x) {
  a <- 2; 
  b <- 1.5; 
  h0 <- 0.25
  
  r <- a*tanh(x*b)
  r[r < h0] <- h0
  return(r)
}
ttops <- find_trees(chm, lmf(ws = ws_fn, hmin = .1, shape = "circular")) |> 
  st_as_sf()
```
Visualize the output over the Canopy Height Model and (optionally) true colour imagery:

```{r, message=FALSE}
f <- list.files(path_prj, pattern = "_ortho_", full.names = TRUE)
if(length(f) == 1) {
  ortho <- rast(f)
  plotRGB(ortho)
  plot(ttops$geometry, add = TRUE, pch = 4, col = "darkblue")
}

plot(chm)
plot(ttops$geometry, add = TRUE, pch = 4, col = "darkblue")
```

#### 3. Outline segment boundaries and visualize the output. 
The performance of the region growing algorithm depends on two parameters: `max_cr_factor` and `exclusion`.\
3.1 Based on the `silva2016()` documentation, `max_cr_factor` is the expected maximum width of a shrub given its height. For example, using `0.5` means that we expect that the diameter of a 1m tall shrub is 0.5m. Since sagebrush can be a pretty wide plant at its mature state, values >1 will indicate that the width can be bigger than the height.\
3.2 The value of the `exclusion` parameter needs to be between 0 and 1 and it determins to what degree the edges of the plants will be included, or excluded, from the segments. For example, assuming the plant is 2m tall and we choose `exclusion = 0.25`, pixels of the CHM with values below `2 * 0.25 = .5` will be excluded from the edges of the segment. Similarly, for a plant that is 0.4m tall CHM values below 0.1 will be excluded. In other words, smaller values will add more pixels to the segments around its edges.
 

```{r}
# segment trees in CHM
set.values(chm)
cro <- silva2016(chm, ttops, max_cr_factor = 1.5, exclusion = 0.35)()

plot(chm, col = cols)
plot(cro, add = TRUE, col = sample(colsid))
plot(ttops$geometry, add = TRUE, pch = 19, cex = .5, col = "black")
```

#### 4. Export output.
This chunk takes the outputs from **Step 2** and **Step 3** and exports it to subfolder in the project directory `path_prj`. If we ran a test dataset, exporting the output is not necessary but is totally fine, we can explore it in, say, QGIS or other software. Otherwise, to run the fine-tuned parameters on the full dataset we'd need to go back to **Step 1**, set `Test = 0`, and run the remaining steps again using the same paramters as we did for the test run. 
```{r, message=FALSE, warning=FALSE}
# optionally, we could define some region of interest (roi) using a buffer distance from the edge of the raster. This could be used to avoid boundary effects on the segmented crowns. Setting st_buffer(0) will result in no effect.
roi <- chm |> 
  st_bbox() |> 
  st_as_sfc() |> 
  st_buffer(0)

# tree tops
tout <- ttops |> 
  st_crop(st_bbox(roi)) 

# polygons
cout <- cro |> 
  st_as_stars() |> 
  st_as_sf(as_points = FALSE, merge = TRUE) |> 
  rename(treeID = dsm) |>
  mutate(var = lengths(st_intersects(geometry, st_buffer(tout, 0.1))) ) |>
  filter(var == 1) |> dplyr::select(-var)

# save output to disk as a shapefile
tout |> 
  filter(treeID %in% cout$treeID) |>
    st_write(paste0(path_out, site, "_ttops.shp"), delete_layer = TRUE)

cout |> 
    st_write(paste0(path_out, site, "_crown.shp"), delete_layer = TRUE)

writeRaster(cro, filename = paste0(path_out, site, "_crown_raster.tif"), overwrite = TRUE)
```

---

#### Test code for cloud-based tree detection.

```{r, message=FALSE}
dir.create(paste0(path_prj, "../chm_cloud/"), showWarnings = FALSE)

ctg <- readLAScatalog(paste0(path_prj, "../chm_cloud/"))

f <- list.files(paste0(path_prj, "../"), pattern = "_dtm_", full.names = TRUE)
dtm <- rast(f) |>
  crop(extent(ctg)*2) 
set.values(dtm)

opt_output_files(ctg) <- paste0(path_prj, "../chm_cloud/", "tile_{ID}_norm")

# === normalize height
library(future)
plan(multisession)

ctg_norm <- normalize_height(ctg, raster::raster(dtm))

plan(sequential)

```

```{r}
plan(multisession)

ttops <- locate_trees(ctg_norm, lmf(ws = ws_fn, hmin = .1), uniqueness = "bitmerge")
```

```{r, message=FALSE}
lf <- list.files(paste0(path_prj, "../chm_cloud/"), pattern = ".shp$", full.names = TRUE)

slist <- lapply(lf, st_read)

tt <- do.call(rbind, slist) |>
  group_by(treeID) |>
  slice_max(Z) |>
  ungroup() |>
  mutate(treeID = 1:n())

st_write(tt, paste0(path_prj, "segment_output_2/NorthHam_ttops.shp"), delete_layer = TRUE)
```

```{r}
ttops <- st_read(paste0(path_prj, "segment_output_2/NorthHam_ttops.shp"))

f <- list.files(paste0(path_prj, "../"), pattern = "_chm_", full.names = TRUE)
chm <- rast(f) |>
  crop(extent(ttops)*1.5)


set.values(chm)
cro <- silva2016(chm, ttops, max_cr_factor = 1.5, exclusion = 0.25)()

```

```{r}
# export 
roi <- chm |> 
  st_bbox() |> 
  st_as_sfc() |> 
  st_buffer(-.9)

# tree tops
tout <- ttops |> 
  st_crop(st_bbox(roi)) 

# polygons
cout <- cro |> 
  st_as_stars() |> 
  st_as_sf(as_points = FALSE, merge = TRUE) |> 
  rename(treeID = dsm) |>
  filter(st_intersects(geometry, st_buffer(tout, .1), sparse = FALSE)[,1] ) 

# save output to disk as a shapefile
tout |> 
  filter(treeID %in% cout$treeID) |>
    st_write(paste0(path_out, site, "_ttops.shp"), delete_layer = TRUE)

cout |> 
    st_write(paste0(path_out, site, "_crown.shp"), delete_layer = TRUE)

writeRaster(cro, filename = paste0(path_out, site, "_crown_raster.tif"), overwrite = TRUE)
```
